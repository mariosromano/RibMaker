<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M|R Walls Rib Maker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1f;
            color: white;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        .controls {
            width: 340px;
            padding: 20px;
            background: #2a2a30;
            overflow-y: auto;
            height: 100vh;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
        }

        .brand-logo {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: -1px;
        }

        .brand-logo .divider {
            color: #7c9bff;
            margin: 0 2px;
        }

        h1 {
            font-size: 15px;
            font-weight: 500;
            color: #aaa;
        }

        .subtitle {
            font-size: 11px;
            color: #666;
            margin-bottom: 16px;
        }

        .section {
            background: #3a3a42;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 14px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
            color: #ccc;
        }

        .control-group label span {
            color: #7c9bff;
            font-weight: 500;
            font-family: monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #7c9bff;
            cursor: pointer;
        }

        select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: #555;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }

        input[type="color"] {
            width: 100%;
            height: 36px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 6px;
            border: none;
            border-radius: 6px;
            background: #7c9bff;
            color: white;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #6b8aee;
        }

        button.secondary {
            background: #4a4a52;
        }

        button.secondary:hover {
            background: #5a5a62;
        }

        .view-buttons {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }

        .view-buttons button {
            flex: 1;
            padding: 8px;
            font-size: 11px;
        }

        .mode-indicator {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            text-align: center;
            margin-bottom: 14px;
            font-weight: 500;
        }

        .mode-indicator.wave-mode {
            background: #3a3a52;
            color: #7c9bff;
        }

        .mode-indicator.image-mode {
            background: #2d4a3d;
            color: #4ade80;
        }

        #image-drop-zone {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 12px;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #image-drop-zone:hover,
        #image-drop-zone.drag-over {
            border-color: #7c9bff;
            background: rgba(124, 155, 255, 0.1);
        }

        #image-drop-zone p {
            font-size: 11px;
            color: #888;
            margin: 4px 0;
        }

        #image-drop-zone .icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        #image-preview {
            max-width: 100%;
            max-height: 80px;
            border-radius: 4px;
            display: none;
            margin-top: 8px;
        }

        #image-file-input {
            display: none;
        }

        .image-info {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }

        #dimensions-display {
            font-family: monospace;
            font-size: 11px;
            color: #888;
            padding: 10px;
            background: #1a1a1f;
            border-radius: 4px;
            line-height: 1.8;
        }

        #dimensions-display strong {
            color: #aaa;
        }

        .pricing-box {
            background: #2d4a2d;
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.8;
        }

        .pricing-box .price {
            font-size: 18px;
            font-weight: 700;
            color: #8eff8e;
        }

        .pricing-box strong {
            color: #aaa;
        }

        .curve-info {
            background: #1a1a1f;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 10px;
            color: #666;
        }

        .curve-info span {
            color: #7c9bff;
        }

        .info-box {
            background: #1a1a1f;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 11px;
            color: #666;
            line-height: 1.5;
        }

        .toggle-group {
            display: flex;
            gap: 4px;
            background: #2a2a30;
            border-radius: 6px;
            padding: 3px;
        }

        .toggle-group button {
            flex: 1;
            padding: 8px 12px;
            margin: 0;
            font-size: 11px;
            border-radius: 4px;
            background: transparent;
            color: #888;
            transition: all 0.2s;
        }

        .toggle-group button.active {
            background: #7c9bff;
            color: white;
        }

        .toggle-group button:hover:not(.active) {
            background: #3a3a42;
            color: #ccc;
        }

        .lighting-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .lighting-grid button {
            padding: 8px 6px;
            font-size: 10px;
            margin: 0;
        }

        .lighting-grid button.active {
            background: #7c9bff;
        }

        .led-controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #555;
        }

        .led-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .led-toggle label {
            font-size: 12px;
            color: #ccc;
        }

        .switch {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: 0.3s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #7c9bff;
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        .color-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .color-row .color-item {
            flex: 1;
        }

        .color-row .color-item label {
            display: block;
            font-size: 10px;
            color: #888;
            margin-bottom: 4px;
        }

        .color-row input[type="color"] {
            height: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="canvas-container"></div>
        <div class="controls">
            <div class="brand">
                <div class="brand-logo">M<span class="divider">|</span>R Walls</div>
            </div>
            <h1>Rib Maker</h1>
            <p class="subtitle">Architectural facade panel designer</p>

            <div class="mode-indicator wave-mode" id="mode-indicator">
                Mode: Wave Pattern
            </div>

            <!-- Image Upload Section -->
            <div class="section">
                <div class="section-title">Profile Image (Optional)</div>
                <div id="image-drop-zone">
                    <div class="icon">ðŸ“·</div>
                    <p>Drag & drop image or click to browse</p>
                    <p>Brightness controls rib depth</p>
                    <img id="image-preview" alt="Preview">
                </div>
                <input type="file" id="image-file-input" accept="image/*">
                <button class="secondary" id="clear-image" style="display: none;">Clear Image</button>

                <div id="image-scale-control" style="display: none; margin-top: 12px;">
                    <label>Image Scale <span id="image-scale-value">1.0</span></label>
                    <input type="range" id="image-scale" min="0.1" max="5" value="1" step="0.1">
                    <p class="image-info">Scale &lt; 1: Image tiles/repeats</p>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Array Settings</div>

                <div class="control-group">
                    <label>Number of Ribs <span id="countVal">40</span></label>
                    <input type="range" id="count" min="10" max="80" value="40">
                </div>

                <div class="control-group">
                    <label>Spacing (center to center) <span id="spacingVal">7"</span></label>
                    <input type="range" id="spacing" min="1" max="50" value="7" step="0.5">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Rib Dimensions</div>

                <div class="control-group">
                    <label>Rib Height <span id="heightVal">144"</span></label>
                    <input type="range" id="height" min="40" max="144" value="144" step="1">
                </div>

                <div class="control-group">
                    <label>Min Depth (from wall) <span id="minDepthVal">4"</span></label>
                    <input type="range" id="minDepth" min="2" max="30" value="4" step="0.5">
                </div>

                <div class="control-group">
                    <label>Max Depth (from wall) <span id="maxDepthVal">12"</span></label>
                    <input type="range" id="maxDepth" min="2" max="30" value="12" step="0.5">
                </div>

                <div class="control-group">
                    <label>Rib Thickness</label>
                    <select id="thickness">
                        <option value="0.5" selected>0.5 inch</option>
                        <option value="1">1 inch</option>
                    </select>
                </div>
            </div>

            <div class="section" id="wave-controls">
                <div class="section-title">Wave Pattern</div>

                <div class="control-group">
                    <label>Wave Frequency <span id="frequencyVal">2</span></label>
                    <input type="range" id="frequency" min="0.5" max="5" value="2" step="0.5">
                </div>

                <div class="control-group">
                    <label>Phase Offset <span id="phaseVal">0.25</span></label>
                    <input type="range" id="phase" min="0" max="1" value="0.25" step="0.05">
                </div>

                <div class="control-group">
                    <label>Wave Type <span id="waveTypeVal">Sine</span></label>
                    <input type="range" id="waveType" min="0" max="2" value="0" step="1">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Curve Settings</div>

                <div class="control-group">
                    <label>Control Points <span id="controlPointsVal">20</span></label>
                    <input type="range" id="controlPoints" min="5" max="100" value="20" step="1">
                    <p class="image-info">Points sampled to define curve shape</p>
                </div>

                <div class="control-group">
                    <label>Display Resolution <span id="displayResolutionVal">200</span></label>
                    <input type="range" id="displayResolution" min="50" max="500" value="200" step="10">
                    <p class="image-info">Segments for smooth curve rendering</p>
                </div>

                <div class="curve-info">
                    Control spacing: <span id="controlSpacing">3.60</span>" |
                    Segment size: <span id="segmentSize">0.36</span>"
                </div>
            </div>

            <div class="section">
                <div class="section-title">Installation Mode</div>
                <div class="toggle-group">
                    <button id="wall-mode" class="active" onclick="setInstallationMode('wall')">Wall</button>
                    <button id="ceiling-mode" onclick="setInstallationMode('ceiling')">Ceiling</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">View</div>
                <div class="view-buttons">
                    <button class="secondary" onclick="setView('front')">Front</button>
                    <button class="secondary" onclick="setView('top')">Top</button>
                    <button class="secondary" onclick="setView('side')">Side</button>
                    <button class="secondary" onclick="setView('perspective')">3D</button>
                </div>
                <div class="control-group">
                    <label>Rib Color</label>
                    <input type="color" id="color" value="#ffffff">
                </div>
                <div class="control-group">
                    <label>Wall/Ceiling Color</label>
                    <input type="color" id="backdrop-color" value="#3a3a40" onchange="updateBackdropColor()">
                </div>
                <div class="control-group">
                    <label>Background Color</label>
                    <input type="color" id="bg-color" value="#1a1a1f" onchange="updateBackgroundColor()">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Lighting</div>
                <div class="lighting-grid">
                    <button id="light-standard" class="active" onclick="setLighting('standard')">Standard</button>
                    <button id="light-dramatic" onclick="setLighting('dramatic')">Dramatic</button>
                    <button id="light-sunset" onclick="setLighting('sunset')">Sunset</button>
                    <button id="light-cool" onclick="setLighting('cool')">Cool Studio</button>
                    <button id="light-night" onclick="setLighting('night')">Night</button>
                </div>

                <div class="led-controls">
                    <div class="led-toggle">
                        <label>LED Strip Lighting</label>
                        <label class="switch">
                            <input type="checkbox" id="led-enabled" onchange="toggleLEDs()">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div id="led-color-controls" style="display: none;">
                        <div class="color-row">
                            <div class="color-item">
                                <label>LED Start Color</label>
                                <input type="color" id="led-color-start" value="#ff0066" onchange="updateLEDs()">
                            </div>
                            <div class="color-item">
                                <label>LED End Color</label>
                                <input type="color" id="led-color-end" value="#00ffff" onchange="updateLEDs()">
                            </div>
                        </div>
                        <div class="control-group">
                            <label>LED Intensity <span id="ledIntensityVal">1.0</span></label>
                            <input type="range" id="led-intensity" min="0.1" max="3" value="1" step="0.1" oninput="updateLEDs()">
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Export</div>
                <button onclick="exportImage()">Download Image</button>
                <button onclick="exportDXF()" class="secondary">Export DXF (All Ribs)</button>
                <button onclick="exportCSV()" class="secondary">Export Dimensions CSV</button>
            </div>

            <div id="dimensions-display">
                <strong>Number of Ribs:</strong> <span id="ribCount">--</span><br>
                <strong>Total Array Width:</strong> <span id="totalWidth">--</span><br>
                <strong>Wall Coverage:</strong> <span id="wallCoverage">--</span><br>
                <strong>Surface Area:</strong> <span id="surfaceArea">--</span>
            </div>

            <div class="pricing-box">
                <strong>Estimated Price</strong><br>
                <strong>Ribs:</strong> <span id="surfaceAreaCalc">--</span> @ $38/sf = <span id="ribPrice">--</span><br>
                <span id="ledPriceLine" style="display: none;"><strong>LED:</strong> <span id="ledFootage">--</span> @ $30/lf = <span id="ledPrice">--</span><br></span>
                <span class="price" id="totalPrice">--</span>
            </div>

            <div class="info-box">
                <strong>Controls:</strong> Left-click drag to rotate, right-click drag to pan, scroll to zoom.
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lights/RectAreaLightUniformsLib.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let ribMeshes = [];
        let ribProfiles = [];
        let wallMesh;
        let ceilingMesh;
        let ribGroup;
        let ledLights = [];
        let ledMeshes = [];
        let gridHelper;

        // Image data
        let imageData = null;
        let imageCanvas = null;
        let imageCtx = null;

        // State
        let installationMode = 'wall';
        let currentLighting = 'standard';
        let lightsInScene = [];

        const SCALE = 0.1; // 1 inch = 0.1 units in 3D
        const PRICE_PER_SF = 38;
        const PRICE_LED_PER_LF = 30;
        const waveTypes = ['Sine', 'Smooth', 'Sharp'];

        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1f);

            // Camera
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(15, 10, 25);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Initialize RectAreaLight support for linear LED lighting
            THREE.RectAreaLightUniformsLib.init();

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Rib group container
            ribGroup = new THREE.Group();
            scene.add(ribGroup);

            // Setup initial lighting
            setLighting('standard');

            // Grid helper (represents floor)
            gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x333333);
            scene.add(gridHelper);

            // Axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // Setup event listeners
            setupEventListeners();
            setupImageUpload();

            // Initial build
            updateCurveInfo();
            generateRibs();

            // Handle resize
            window.addEventListener('resize', onWindowResize);

            // Animation loop
            animate();
        }

        function setupEventListeners() {
            const sliders = ['height', 'minDepth', 'maxDepth', 'count', 'spacing', 'frequency', 'phase', 'waveType', 'controlPoints', 'displayResolution'];

            sliders.forEach(id => {
                const el = document.getElementById(id);
                el.addEventListener('input', () => {
                    updateValueDisplays();
                    updateCurveInfo();
                    generateRibs();
                });
            });

            document.getElementById('thickness').addEventListener('change', generateRibs);
            document.getElementById('color').addEventListener('input', generateRibs);

            document.getElementById('image-scale').addEventListener('input', (e) => {
                document.getElementById('image-scale-value').textContent = e.target.value;
                generateRibs();
            });
        }

        function setupImageUpload() {
            const dropZone = document.getElementById('image-drop-zone');
            const fileInput = document.getElementById('image-file-input');
            const clearBtn = document.getElementById('clear-image');

            dropZone.addEventListener('click', () => fileInput.click());

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) loadImage(e.target.files[0]);
            });

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                if (e.dataTransfer.files.length > 0) loadImage(e.dataTransfer.files[0]);
            });

            clearBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                clearImage();
            });
        }

        function loadImage(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    imageCanvas = document.createElement('canvas');
                    imageCanvas.width = img.width;
                    imageCanvas.height = img.height;
                    imageCtx = imageCanvas.getContext('2d');
                    imageCtx.drawImage(img, 0, 0);
                    imageData = imageCtx.getImageData(0, 0, img.width, img.height);

                    const preview = document.getElementById('image-preview');
                    preview.src = e.target.result;
                    preview.style.display = 'block';

                    document.getElementById('clear-image').style.display = 'block';
                    document.getElementById('image-scale-control').style.display = 'block';
                    document.getElementById('wave-controls').style.display = 'none';

                    const modeIndicator = document.getElementById('mode-indicator');
                    modeIndicator.textContent = 'Mode: Image Pattern';
                    modeIndicator.classList.remove('wave-mode');
                    modeIndicator.classList.add('image-mode');

                    generateRibs();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function clearImage() {
            imageData = null;
            imageCanvas = null;
            imageCtx = null;

            document.getElementById('image-preview').style.display = 'none';
            document.getElementById('clear-image').style.display = 'none';
            document.getElementById('image-scale-control').style.display = 'none';
            document.getElementById('wave-controls').style.display = 'block';
            document.getElementById('image-file-input').value = '';

            const modeIndicator = document.getElementById('mode-indicator');
            modeIndicator.textContent = 'Mode: Wave Pattern';
            modeIndicator.classList.remove('image-mode');
            modeIndicator.classList.add('wave-mode');

            generateRibs();
        }

        function sampleImageBrightness(u, v) {
            if (!imageData) return 0.5;

            const scale = parseFloat(document.getElementById('image-scale').value);

            let su = (u / scale) % 1;
            let sv = (v / scale) % 1;
            if (su < 0) su += 1;
            if (sv < 0) sv += 1;

            const px = Math.floor(su * (imageCanvas.width - 1));
            const py = Math.floor((1 - sv) * (imageCanvas.height - 1));

            const idx = (py * imageCanvas.width + px) * 4;
            const r = imageData.data[idx];
            const g = imageData.data[idx + 1];
            const b = imageData.data[idx + 2];

            return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        }

        function getParams() {
            return {
                height: parseFloat(document.getElementById('height').value),
                minDepth: parseFloat(document.getElementById('minDepth').value),
                maxDepth: parseFloat(document.getElementById('maxDepth').value),
                thickness: parseFloat(document.getElementById('thickness').value),
                count: parseInt(document.getElementById('count').value),
                spacing: parseFloat(document.getElementById('spacing').value),
                frequency: parseFloat(document.getElementById('frequency').value),
                phase: parseFloat(document.getElementById('phase').value),
                waveType: parseInt(document.getElementById('waveType').value),
                controlPoints: parseInt(document.getElementById('controlPoints').value),
                displayResolution: parseInt(document.getElementById('displayResolution').value),
                color: document.getElementById('color').value
            };
        }

        function waveFunction(t, frequency, waveType, phaseShift) {
            const angle = t * frequency * Math.PI * 2 + phaseShift;
            switch(waveType) {
                case 0: return Math.sin(angle);
                case 1: return Math.sin(angle) * Math.abs(Math.sin(angle));
                case 2: return Math.asin(Math.sin(angle)) / (Math.PI / 2);
                default: return Math.sin(angle);
            }
        }

        function generateControlPoints(params, ribIndex) {
            const { height, minDepth, maxDepth, frequency, phase, waveType, controlPoints, count } = params;
            const points = [];
            const depthRange = maxDepth - minDepth;
            const phaseShift = ribIndex * phase * Math.PI * 2;

            for (let i = 0; i < controlPoints; i++) {
                const t = i / (controlPoints - 1);
                const y = t * height;

                let depth;
                if (imageData) {
                    const u = count > 1 ? ribIndex / (count - 1) : 0.5;
                    const brightness = sampleImageBrightness(u, t);
                    depth = minDepth + brightness * depthRange;
                } else {
                    const wave = waveFunction(t, frequency, waveType, phaseShift);
                    depth = minDepth + (wave + 1) / 2 * depthRange;
                }

                points.push(new THREE.Vector2(depth, y));
            }

            return points;
        }

        function evaluateSplineCurve(controlPoints, resolution) {
            const curve = new THREE.SplineCurve(controlPoints);
            return curve.getPoints(resolution);
        }

        function createRibGeometry(profile, thickness, height) {
            const shape = new THREE.Shape();

            shape.moveTo(0, 0);

            profile.forEach((point) => {
                shape.lineTo(point.x * SCALE, point.y * SCALE);
            });

            shape.lineTo(0, height * SCALE);
            shape.lineTo(0, 0);

            const extrudeSettings = {
                depth: thickness * SCALE,
                bevelEnabled: false
            };

            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
        }

        function generateRibs() {
            // Clear existing ribs from group
            ribMeshes.forEach(mesh => ribGroup.remove(mesh));
            ribMeshes = [];
            ribProfiles = [];
            if (wallMesh) {
                ribGroup.remove(wallMesh);
                wallMesh = null;
            }
            if (ceilingMesh) {
                ribGroup.remove(ceilingMesh);
                ceilingMesh = null;
            }
            clearLEDs();

            const params = getParams();
            const { height, thickness, count, spacing, displayResolution, color, maxDepth } = params;

            // Validate min/max
            const actualMinDepth = Math.min(params.minDepth, params.maxDepth);
            const actualMaxDepth = Math.max(params.minDepth, params.maxDepth);
            params.minDepth = actualMinDepth;
            params.maxDepth = actualMaxDepth;

            // Material
            const material = new THREE.MeshPhongMaterial({
                color: new THREE.Color(color),
                side: THREE.DoubleSide,
                shininess: 30
            });

            // Calculate positions
            const totalWidth = (count - 1) * spacing;
            const startZ = -(totalWidth * SCALE) / 2;

            // Generate each rib
            for (let i = 0; i < count; i++) {
                const controlPoints = generateControlPoints(params, i);
                const profile = evaluateSplineCurve(controlPoints, displayResolution);

                ribProfiles.push({
                    index: i,
                    profile: profile,
                    controlPoints: controlPoints,
                    height: height,
                    thickness: thickness
                });

                const geometry = createRibGeometry(profile, thickness, height);
                const mesh = new THREE.Mesh(geometry, material);

                mesh.position.z = startZ + i * spacing * SCALE - thickness * SCALE / 2;
                mesh.castShadow = true;
                mesh.receiveShadow = true;

                ribGroup.add(mesh);
                ribMeshes.push(mesh);
            }

            // Get backdrop color from picker
            const backdropColor = document.getElementById('backdrop-color').value;

            // Wall or ceiling backdrop based on mode
            if (installationMode === 'wall') {
                // Wall: vertical plane behind ribs at X=0
                const wallGeometry = new THREE.PlaneGeometry((totalWidth + 40) * SCALE, (height + 10) * SCALE);
                const wallMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(backdropColor),
                    side: THREE.DoubleSide
                });
                wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                wallMesh.rotation.y = Math.PI / 2;
                wallMesh.position.set(-0.5 * SCALE, height * SCALE / 2, 0);
                wallMesh.receiveShadow = true;
                ribGroup.add(wallMesh);

                // Reset position and rotation for wall mode
                ribGroup.rotation.set(0, 0, 0);
                ribGroup.position.set(0, 0, 0);
            } else {
                // Ceiling mode - ribs rotate to hang from ceiling
                // Ceiling plane: horizontal, same size as wall backdrop
                const ceilingGeometry = new THREE.PlaneGeometry((totalWidth + 40) * SCALE, (height + 10) * SCALE);
                const ceilingMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(backdropColor),
                    side: THREE.DoubleSide
                });
                ceilingMesh = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                // Same orientation as wall but will be rotated with group
                ceilingMesh.rotation.y = Math.PI / 2;
                ceilingMesh.position.set(-0.5 * SCALE, height * SCALE / 2, 0);
                ceilingMesh.receiveShadow = true;
                ribGroup.add(ceilingMesh);

                // Rotate entire group -90Â° around Z so ribs hang down from ceiling
                // This makes: original Y (height) -> X (horizontal), original X (wave) -> -Y (down)
                ribGroup.rotation.set(0, 0, -Math.PI / 2);
                // Reposition so ceiling is at top
                ribGroup.position.set(height * SCALE / 2, actualMaxDepth * SCALE / 2, 0);
            }

            // Update LEDs if enabled
            if (document.getElementById('led-enabled').checked) {
                createLEDs();
            }

            // Update displays
            updateDimensionsDisplay(params, totalWidth);
        }

        function updateValueDisplays() {
            document.getElementById('heightVal').textContent = document.getElementById('height').value + '"';
            document.getElementById('minDepthVal').textContent = document.getElementById('minDepth').value + '"';
            document.getElementById('maxDepthVal').textContent = document.getElementById('maxDepth').value + '"';
            document.getElementById('countVal').textContent = document.getElementById('count').value;
            document.getElementById('spacingVal').textContent = document.getElementById('spacing').value + '"';
            document.getElementById('frequencyVal').textContent = document.getElementById('frequency').value;
            document.getElementById('phaseVal').textContent = document.getElementById('phase').value;
            document.getElementById('waveTypeVal').textContent = waveTypes[document.getElementById('waveType').value];
            document.getElementById('controlPointsVal').textContent = document.getElementById('controlPoints').value;
            document.getElementById('displayResolutionVal').textContent = document.getElementById('displayResolution').value;
        }

        function updateCurveInfo() {
            const height = parseFloat(document.getElementById('height').value);
            const controlPoints = parseInt(document.getElementById('controlPoints').value);
            const displayResolution = parseInt(document.getElementById('displayResolution').value);

            const controlSpacing = height / (controlPoints - 1);
            const segmentSize = height / displayResolution;

            document.getElementById('controlSpacing').textContent = controlSpacing.toFixed(2);
            document.getElementById('segmentSize').textContent = segmentSize.toFixed(3);
        }

        function updateDimensionsDisplay(params, totalWidth) {
            document.getElementById('ribCount').textContent = params.count;
            document.getElementById('totalWidth').textContent = totalWidth.toFixed(1) + '" (' + (totalWidth / 12).toFixed(1) + "')";
            document.getElementById('wallCoverage').textContent =
                (totalWidth / 12).toFixed(1) + "' wide x " + (params.height / 12).toFixed(1) + "' tall";

            // Rib surface area calculation
            const surfaceAreaPerRibSqIn = params.height * params.maxDepth;
            const surfaceAreaPerRibSqFt = surfaceAreaPerRibSqIn / 144;
            const totalSurfaceAreaSqFt = surfaceAreaPerRibSqFt * params.count;

            document.getElementById('surfaceArea').textContent = totalSurfaceAreaSqFt.toFixed(1) + ' sf';
            document.getElementById('surfaceAreaCalc').textContent = totalSurfaceAreaSqFt.toFixed(1) + ' sf';

            // Rib price
            const ribPrice = totalSurfaceAreaSqFt * PRICE_PER_SF;
            document.getElementById('ribPrice').textContent = '$' + ribPrice.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });

            // LED pricing (linear feet = rib height in feet Ã— number of ribs)
            const ledEnabled = document.getElementById('led-enabled').checked;
            const ledLinearFeet = (params.height / 12) * params.count;
            const ledPrice = ledLinearFeet * PRICE_LED_PER_LF;

            if (ledEnabled) {
                document.getElementById('ledPriceLine').style.display = 'block';
                document.getElementById('ledFootage').textContent = ledLinearFeet.toFixed(1) + ' lf';
                document.getElementById('ledPrice').textContent = '$' + ledPrice.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            } else {
                document.getElementById('ledPriceLine').style.display = 'none';
            }

            // Total price
            const totalPrice = ribPrice + (ledEnabled ? ledPrice : 0);
            document.getElementById('totalPrice').textContent = '$' + totalPrice.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
        }

        function setView(view) {
            const params = getParams();
            const totalWidth = (params.count - 1) * params.spacing * SCALE;
            const centerY = params.height * SCALE / 2;
            const maxD = params.maxDepth * SCALE;

            switch(view) {
                case 'front':
                    camera.position.set(maxD + 15, centerY, 0);
                    controls.target.set(0, centerY, 0);
                    break;
                case 'top':
                    camera.position.set(0, 20, 0);
                    controls.target.set(0, 0, 0);
                    break;
                case 'side':
                    camera.position.set(maxD / 2, centerY, totalWidth + 10);
                    controls.target.set(maxD / 2, centerY, 0);
                    break;
                case 'perspective':
                    camera.position.set(15, 10, 25);
                    controls.target.set(0, centerY, 0);
                    break;
            }
            controls.update();
        }

        function exportImage() {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = 'mr-walls-ribs.png';
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        }

        function exportDXF() {
            const params = getParams();
            const height = params.height;
            const maxDepth = params.maxDepth;
            const dxfSpacing = maxDepth * 1.2;

            let dxf = '';

            // DXF R12 format header
            dxf += '0\nSECTION\n2\nHEADER\n';
            dxf += '9\n$ACADVER\n1\nAC1009\n';
            dxf += '9\n$INSUNITS\n70\n1\n';
            dxf += '0\nENDSEC\n';

            // Tables section with layers
            dxf += '0\nSECTION\n2\nTABLES\n';
            dxf += '0\nTABLE\n2\nLAYER\n70\n2\n';
            dxf += '0\nLAYER\n2\nCURVES\n70\n0\n62\n5\n6\nCONTINUOUS\n';
            dxf += '0\nLAYER\n2\nLINES\n70\n0\n62\n7\n6\nCONTINUOUS\n';
            dxf += '0\nENDTAB\n';
            dxf += '0\nENDSEC\n';

            // Entities section
            dxf += '0\nSECTION\n2\nENTITIES\n';

            ribProfiles.forEach((rib, ribIndex) => {
                const offsetX = ribIndex * dxfSpacing;
                const profile = rib.profile;
                const firstPoint = profile[0];
                const lastPoint = profile[profile.length - 1];

                // Bottom edge line
                dxf += '0\nLINE\n8\nLINES\n';
                dxf += `10\n${offsetX.toFixed(6)}\n20\n0.0\n30\n0.0\n`;
                dxf += `11\n${(offsetX + firstPoint.x).toFixed(6)}\n21\n${firstPoint.y.toFixed(6)}\n31\n0.0\n`;

                // Curved edge as spline polyline
                dxf += '0\nPOLYLINE\n8\nCURVES\n66\n1\n70\n4\n';

                profile.forEach(point => {
                    dxf += '0\nVERTEX\n8\nCURVES\n';
                    dxf += `10\n${(offsetX + point.x).toFixed(6)}\n20\n${point.y.toFixed(6)}\n30\n0.0\n70\n8\n`;
                });

                dxf += '0\nSEQEND\n8\nCURVES\n';

                // Top edge line
                dxf += '0\nLINE\n8\nLINES\n';
                dxf += `10\n${(offsetX + lastPoint.x).toFixed(6)}\n20\n${lastPoint.y.toFixed(6)}\n30\n0.0\n`;
                dxf += `11\n${offsetX.toFixed(6)}\n21\n${height.toFixed(6)}\n31\n0.0\n`;

                // Left edge line (straight, at wall)
                dxf += '0\nLINE\n8\nLINES\n';
                dxf += `10\n${offsetX.toFixed(6)}\n20\n${height.toFixed(6)}\n30\n0.0\n`;
                dxf += `11\n${offsetX.toFixed(6)}\n21\n0.0\n31\n0.0\n`;
            });

            dxf += '0\nENDSEC\n0\nEOF\n';

            downloadFile(dxf, 'mr-walls-ribs.dxf', 'application/dxf');
        }

        function exportCSV() {
            const params = getParams();
            let csv = 'Rib Index,Height (in),Min Depth (in),Max Depth (in),Thickness (in),Phase Shift (rad)\n';

            for (let i = 0; i < params.count; i++) {
                const phaseShift = i * params.phase * Math.PI * 2;
                csv += `${i},${params.height},${params.minDepth},${params.maxDepth},${params.thickness},${phaseShift.toFixed(4)}\n`;
            }

            csv += `\nArray Settings\n`;
            csv += `Total Ribs,${params.count}\n`;
            csv += `Spacing,${params.spacing}"\n`;
            csv += `Total Width,${((params.count - 1) * params.spacing).toFixed(2)}"\n`;
            csv += `Wave Frequency,${params.frequency}\n`;
            csv += `Wave Type,${waveTypes[params.waveType]}\n`;
            csv += `Control Points,${params.controlPoints}\n`;
            csv += `Display Resolution,${params.displayResolution}\n`;

            const surfaceAreaPerRibSqFt = (params.height * params.maxDepth) / 144;
            const totalSurfaceAreaSqFt = surfaceAreaPerRibSqFt * params.count;
            const ribPrice = totalSurfaceAreaSqFt * PRICE_PER_SF;

            csv += `\nPricing\n`;
            csv += `Surface Area per Rib,${surfaceAreaPerRibSqFt.toFixed(2)} sf\n`;
            csv += `Total Surface Area,${totalSurfaceAreaSqFt.toFixed(2)} sf\n`;
            csv += `Rib Price per SF,$${PRICE_PER_SF}\n`;
            csv += `Rib Total,$${ribPrice.toFixed(2)}\n`;

            // LED pricing
            const ledEnabled = document.getElementById('led-enabled').checked;
            const ledLinearFeet = (params.height / 12) * params.count;
            const ledPrice = ledLinearFeet * PRICE_LED_PER_LF;

            csv += `\nLED Lighting,${ledEnabled ? 'Yes' : 'No'}\n`;
            if (ledEnabled) {
                csv += `LED Linear Feet,${ledLinearFeet.toFixed(2)} lf\n`;
                csv += `LED Price per LF,$${PRICE_LED_PER_LF}\n`;
                csv += `LED Total,$${ledPrice.toFixed(2)}\n`;
            }

            const totalPrice = ribPrice + (ledEnabled ? ledPrice : 0);
            csv += `\nGrand Total,$${totalPrice.toFixed(2)}\n`;

            downloadFile(csv, 'mr-walls-ribs.csv', 'text/csv');
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Installation Mode
        function setInstallationMode(mode) {
            installationMode = mode;

            document.getElementById('wall-mode').classList.toggle('active', mode === 'wall');
            document.getElementById('ceiling-mode').classList.toggle('active', mode === 'ceiling');

            generateRibs();

            // Adjust camera and grid for the mode
            const params = getParams();
            const centerY = params.height * SCALE / 2;
            const maxD = params.maxDepth * SCALE;
            const floorLevel = -120 * SCALE; // 10 feet down (average ceiling height)

            if (mode === 'ceiling') {
                // Move grid down to represent floor (10' below ceiling)
                gridHelper.position.y = floorLevel;
                // View from side/below to see ceiling with ribs hanging down
                camera.position.set(centerY + 10, floorLevel + 5, 20);
                controls.target.set(centerY, floorLevel / 2, 0);
            } else {
                // Grid at ground level for wall mode
                gridHelper.position.y = 0;
                camera.position.set(15, 10, 25);
                controls.target.set(0, centerY, 0);
            }
            controls.update();
        }

        // Lighting Presets
        function setLighting(preset) {
            currentLighting = preset;

            // Update button states
            document.querySelectorAll('.lighting-grid button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('light-' + preset).classList.add('active');

            // Clear existing lights
            lightsInScene.forEach(light => scene.remove(light));
            lightsInScene = [];

            // Set background color based on preset
            const presets = {
                standard: {
                    background: 0x1a1a1f,
                    ambient: { color: 0xffffff, intensity: 0.4 },
                    lights: [
                        { type: 'directional', color: 0xffffff, intensity: 0.8, position: [10, 20, 10], castShadow: true },
                        { type: 'directional', color: 0xffffff, intensity: 0.3, position: [-10, 10, -10] }
                    ]
                },
                dramatic: {
                    background: 0x0a0a0f,
                    ambient: { color: 0x222244, intensity: 0.15 },
                    lights: [
                        { type: 'spot', color: 0xffffff, intensity: 1.5, position: [20, 15, 0], target: [0, 4, 0], angle: 0.4, castShadow: true },
                        { type: 'directional', color: 0x4444ff, intensity: 0.2, position: [-15, 5, 10] }
                    ]
                },
                sunset: {
                    background: 0x1a1015,
                    ambient: { color: 0xff6633, intensity: 0.2 },
                    lights: [
                        { type: 'directional', color: 0xff8844, intensity: 1.0, position: [25, 8, 5], castShadow: true },
                        { type: 'directional', color: 0xff4422, intensity: 0.5, position: [20, 3, -10] },
                        { type: 'directional', color: 0x6644aa, intensity: 0.3, position: [-10, 15, 0] }
                    ]
                },
                cool: {
                    background: 0x0f1520,
                    ambient: { color: 0x8899cc, intensity: 0.3 },
                    lights: [
                        { type: 'directional', color: 0xaaccff, intensity: 0.7, position: [10, 20, 10], castShadow: true },
                        { type: 'directional', color: 0x88aaff, intensity: 0.5, position: [-10, 15, 10] },
                        { type: 'directional', color: 0x6688cc, intensity: 0.3, position: [0, 10, -15] }
                    ]
                },
                night: {
                    background: 0x050508,
                    ambient: { color: 0x111133, intensity: 0.1 },
                    lights: [
                        { type: 'point', color: 0x4466ff, intensity: 0.8, position: [5, 8, 5] },
                        { type: 'point', color: 0x6644aa, intensity: 0.5, position: [-5, 6, -5] },
                        { type: 'directional', color: 0x222244, intensity: 0.2, position: [0, 20, 0] }
                    ]
                }
            };

            const config = presets[preset];
            scene.background = new THREE.Color(config.background);

            // Sync the background color picker with preset
            const bgHex = '#' + new THREE.Color(config.background).getHexString();
            document.getElementById('bg-color').value = bgHex;

            // Ambient light
            const ambient = new THREE.AmbientLight(config.ambient.color, config.ambient.intensity);
            scene.add(ambient);
            lightsInScene.push(ambient);

            // Other lights
            config.lights.forEach(lightConfig => {
                let light;

                if (lightConfig.type === 'directional') {
                    light = new THREE.DirectionalLight(lightConfig.color, lightConfig.intensity);
                    light.position.set(...lightConfig.position);
                } else if (lightConfig.type === 'spot') {
                    light = new THREE.SpotLight(lightConfig.color, lightConfig.intensity);
                    light.position.set(...lightConfig.position);
                    light.angle = lightConfig.angle || 0.5;
                    light.penumbra = 0.3;
                    if (lightConfig.target) {
                        light.target.position.set(...lightConfig.target);
                        scene.add(light.target);
                    }
                } else if (lightConfig.type === 'point') {
                    light = new THREE.PointLight(lightConfig.color, lightConfig.intensity, 30);
                    light.position.set(...lightConfig.position);
                }

                if (lightConfig.castShadow) {
                    light.castShadow = true;
                    if (light.shadow) {
                        light.shadow.mapSize.width = 1024;
                        light.shadow.mapSize.height = 1024;
                    }
                }

                scene.add(light);
                lightsInScene.push(light);
            });
        }

        // LED Lighting
        function toggleLEDs() {
            const enabled = document.getElementById('led-enabled').checked;
            document.getElementById('led-color-controls').style.display = enabled ? 'block' : 'none';

            if (enabled) {
                createLEDs();
            } else {
                clearLEDs();
            }

            // Update pricing to include/exclude LED cost
            const params = getParams();
            const totalWidth = (params.count - 1) * params.spacing;
            updateDimensionsDisplay(params, totalWidth);
        }

        function clearLEDs() {
            ledLights.forEach(light => ribGroup.remove(light));
            ledMeshes.forEach(mesh => ribGroup.remove(mesh));
            ledLights = [];
            ledMeshes = [];
        }

        function updateLEDs() {
            document.getElementById('ledIntensityVal').textContent = document.getElementById('led-intensity').value;
            if (document.getElementById('led-enabled').checked) {
                clearLEDs();
                createLEDs();
            }
        }

        function createLEDs() {
            if (!ribProfiles.length) return;

            const startColor = new THREE.Color(document.getElementById('led-color-start').value);
            const endColor = new THREE.Color(document.getElementById('led-color-end').value);
            const intensity = parseFloat(document.getElementById('led-intensity').value);

            const params = getParams();
            const totalWidth = (params.count - 1) * params.spacing;
            const startZ = -(totalWidth * SCALE) / 2;

            // Add lights every N ribs for performance
            const lightInterval = Math.max(1, Math.floor(params.count / 20));

            ribProfiles.forEach((rib, i) => {
                // Calculate gradient color for this rib
                const t = params.count > 1 ? i / (params.count - 1) : 0;
                const ribColor = new THREE.Color().lerpColors(startColor, endColor, t);

                const profile = rib.profile;

                // Create glowing LED strip mesh along rib edge
                const sampleRate = Math.max(1, Math.floor(profile.length / 25));
                const points = [];
                for (let p = 0; p < profile.length; p += sampleRate) {
                    const pt = profile[p];
                    points.push(new THREE.Vector3(pt.x * SCALE + 0.02, pt.y * SCALE, 0));
                }

                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, 20, 0.015, 4, false);
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: ribColor,
                    transparent: true,
                    opacity: 0.95
                });

                const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tubeMesh.position.z = startZ + i * params.spacing * SCALE - params.thickness * SCALE / 2;
                ribGroup.add(tubeMesh);
                ledMeshes.push(tubeMesh);

                // Add point lights distributed along rib height (simulates linear LED strip)
                if (i % lightInterval === 0) {
                    // 6 point lights evenly spaced along the rib height for linear effect
                    const numLights = 6;
                    for (let j = 0; j < numLights; j++) {
                        const lt = (j + 0.5) / numLights;  // Even distribution
                        const pointIndex = Math.floor(lt * (profile.length - 1));
                        const point = profile[pointIndex];

                        // Point light positioned at rib edge, casts onto neighboring rib
                        const light = new THREE.PointLight(ribColor, intensity * 0.5, params.spacing * SCALE * 2.5);
                        light.position.set(
                            point.x * SCALE + 0.05,  // Slightly off the rib edge
                            point.y * SCALE,
                            startZ + i * params.spacing * SCALE + params.thickness * SCALE * 0.6
                        );

                        ribGroup.add(light);
                        ledLights.push(light);
                    }
                }
            });
        }

        function updateBackdropColor() {
            const color = document.getElementById('backdrop-color').value;
            if (wallMesh) {
                wallMesh.material.color.set(color);
            }
            if (ceilingMesh) {
                ceilingMesh.material.color.set(color);
            }
        }

        function updateBackgroundColor() {
            const color = document.getElementById('bg-color').value;
            scene.background = new THREE.Color(color);
        }

        // Initialize
        init();
        updateValueDisplays();
    </script>
</body>
</html>
