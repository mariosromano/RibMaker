<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M|R Walls Rib Maker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1f;
            color: white;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        .controls {
            width: 340px;
            padding: 20px;
            background: #2a2a30;
            overflow-y: auto;
            height: 100vh;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
        }

        .brand-logo {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: -1px;
        }

        .brand-logo .divider {
            color: #7c9bff;
            margin: 0 2px;
        }

        h1 {
            font-size: 15px;
            font-weight: 500;
            color: #aaa;
        }

        .subtitle {
            font-size: 11px;
            color: #666;
            margin-bottom: 16px;
        }

        .section {
            background: #3a3a42;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 14px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 600;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
            color: #ccc;
        }

        .control-group label span {
            color: #7c9bff;
            font-weight: 500;
            font-family: monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #7c9bff;
            cursor: pointer;
        }

        select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: #555;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }

        input[type="color"] {
            width: 100%;
            height: 36px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 6px;
            border: none;
            border-radius: 6px;
            background: #7c9bff;
            color: white;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #6b8aee;
        }

        button.secondary {
            background: #4a4a52;
        }

        button.secondary:hover {
            background: #5a5a62;
        }

        .view-buttons {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }

        .view-buttons button {
            flex: 1;
            padding: 8px;
            font-size: 11px;
        }

        .mode-indicator {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            text-align: center;
            margin-bottom: 14px;
            font-weight: 500;
        }

        .mode-indicator.wave-mode {
            background: #3a3a52;
            color: #7c9bff;
        }

        .mode-indicator.image-mode {
            background: #2d4a3d;
            color: #4ade80;
        }

        #image-drop-zone {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 12px;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #image-drop-zone:hover,
        #image-drop-zone.drag-over {
            border-color: #7c9bff;
            background: rgba(124, 155, 255, 0.1);
        }

        #image-drop-zone p {
            font-size: 11px;
            color: #888;
            margin: 4px 0;
        }

        #image-drop-zone .icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        #image-preview {
            max-width: 100%;
            max-height: 80px;
            border-radius: 4px;
            display: none;
            margin-top: 8px;
        }

        #image-file-input {
            display: none;
        }

        .image-info {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }

        #dimensions-display {
            font-family: monospace;
            font-size: 11px;
            color: #888;
            padding: 10px;
            background: #1a1a1f;
            border-radius: 4px;
            line-height: 1.8;
        }

        #dimensions-display strong {
            color: #aaa;
        }

        .pricing-box {
            background: #2d4a2d;
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.8;
        }

        .pricing-box .price {
            font-size: 18px;
            font-weight: 700;
            color: #8eff8e;
        }

        .pricing-box strong {
            color: #aaa;
        }

        .curve-info {
            background: #1a1a1f;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 10px;
            color: #666;
        }

        .curve-info span {
            color: #7c9bff;
        }

        .info-box {
            background: #1a1a1f;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 11px;
            color: #666;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="canvas-container"></div>
        <div class="controls">
            <div class="brand">
                <div class="brand-logo">M<span class="divider">|</span>R Walls</div>
            </div>
            <h1>Rib Maker</h1>
            <p class="subtitle">Architectural facade panel designer</p>

            <div class="mode-indicator wave-mode" id="mode-indicator">
                Mode: Wave Pattern
            </div>

            <!-- Image Upload Section -->
            <div class="section">
                <div class="section-title">Profile Image (Optional)</div>
                <div id="image-drop-zone">
                    <div class="icon">ðŸ“·</div>
                    <p>Drag & drop image or click to browse</p>
                    <p>Brightness controls rib depth</p>
                    <img id="image-preview" alt="Preview">
                </div>
                <input type="file" id="image-file-input" accept="image/*">
                <button class="secondary" id="clear-image" style="display: none;">Clear Image</button>

                <div id="image-scale-control" style="display: none; margin-top: 12px;">
                    <label>Image Scale <span id="image-scale-value">1.0</span></label>
                    <input type="range" id="image-scale" min="0.1" max="5" value="1" step="0.1">
                    <p class="image-info">Scale &lt; 1: Image tiles/repeats</p>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Array Settings</div>

                <div class="control-group">
                    <label>Number of Ribs <span id="countVal">20</span></label>
                    <input type="range" id="count" min="10" max="80" value="20">
                </div>

                <div class="control-group">
                    <label>Spacing (center to center) <span id="spacingVal">1"</span></label>
                    <input type="range" id="spacing" min="1" max="50" value="1" step="0.5">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Rib Dimensions</div>

                <div class="control-group">
                    <label>Rib Height <span id="heightVal">72"</span></label>
                    <input type="range" id="height" min="40" max="144" value="72" step="1">
                </div>

                <div class="control-group">
                    <label>Min Depth (from wall) <span id="minDepthVal">4"</span></label>
                    <input type="range" id="minDepth" min="2" max="30" value="4" step="0.5">
                </div>

                <div class="control-group">
                    <label>Max Depth (from wall) <span id="maxDepthVal">12"</span></label>
                    <input type="range" id="maxDepth" min="2" max="30" value="12" step="0.5">
                </div>

                <div class="control-group">
                    <label>Rib Thickness</label>
                    <select id="thickness">
                        <option value="0.5">0.5 inch</option>
                        <option value="1" selected>1 inch</option>
                    </select>
                </div>
            </div>

            <div class="section" id="wave-controls">
                <div class="section-title">Wave Pattern</div>

                <div class="control-group">
                    <label>Wave Frequency <span id="frequencyVal">2</span></label>
                    <input type="range" id="frequency" min="0.5" max="5" value="2" step="0.5">
                </div>

                <div class="control-group">
                    <label>Phase Offset <span id="phaseVal">0.25</span></label>
                    <input type="range" id="phase" min="0" max="1" value="0.25" step="0.05">
                </div>

                <div class="control-group">
                    <label>Wave Type <span id="waveTypeVal">Sine</span></label>
                    <input type="range" id="waveType" min="0" max="2" value="0" step="1">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Curve Settings</div>

                <div class="control-group">
                    <label>Control Points <span id="controlPointsVal">20</span></label>
                    <input type="range" id="controlPoints" min="5" max="100" value="20" step="1">
                    <p class="image-info">Points sampled to define curve shape</p>
                </div>

                <div class="control-group">
                    <label>Display Resolution <span id="displayResolutionVal">200</span></label>
                    <input type="range" id="displayResolution" min="50" max="500" value="200" step="10">
                    <p class="image-info">Segments for smooth curve rendering</p>
                </div>

                <div class="curve-info">
                    Control spacing: <span id="controlSpacing">3.60</span>" |
                    Segment size: <span id="segmentSize">0.36</span>"
                </div>
            </div>

            <div class="section">
                <div class="section-title">View</div>
                <div class="view-buttons">
                    <button class="secondary" onclick="setView('front')">Front</button>
                    <button class="secondary" onclick="setView('top')">Top</button>
                    <button class="secondary" onclick="setView('side')">Side</button>
                    <button class="secondary" onclick="setView('perspective')">3D</button>
                </div>
                <div class="control-group">
                    <label>Rib Color</label>
                    <input type="color" id="color" value="#7c9bff">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Export</div>
                <button onclick="exportImage()">Download Image</button>
                <button onclick="exportDXF()" class="secondary">Export DXF (All Ribs)</button>
                <button onclick="exportCSV()" class="secondary">Export Dimensions CSV</button>
            </div>

            <div id="dimensions-display">
                <strong>Number of Ribs:</strong> <span id="ribCount">--</span><br>
                <strong>Total Array Width:</strong> <span id="totalWidth">--</span><br>
                <strong>Wall Coverage:</strong> <span id="wallCoverage">--</span><br>
                <strong>Surface Area:</strong> <span id="surfaceArea">--</span>
            </div>

            <div class="pricing-box">
                <strong>Estimated Price</strong><br>
                <span id="surfaceAreaCalc">--</span> @ $50/sf<br>
                <span class="price" id="totalPrice">--</span>
            </div>

            <div class="info-box">
                <strong>Controls:</strong> Left-click drag to rotate, right-click drag to pan, scroll to zoom.
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let ribMeshes = [];
        let ribProfiles = [];
        let wallMesh;

        // Image data
        let imageData = null;
        let imageCanvas = null;
        let imageCtx = null;

        const SCALE = 0.1; // 1 inch = 0.1 units in 3D
        const PRICE_PER_SF = 50;
        const waveTypes = ['Sine', 'Smooth', 'Sharp'];

        function init() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1f);

            // Camera
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(15, 10, 25);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-10, 10, -10);
            scene.add(directionalLight2);

            // Grid helper
            const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x333333);
            scene.add(gridHelper);

            // Axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // Setup event listeners
            setupEventListeners();
            setupImageUpload();

            // Initial build
            updateCurveInfo();
            generateRibs();

            // Handle resize
            window.addEventListener('resize', onWindowResize);

            // Animation loop
            animate();
        }

        function setupEventListeners() {
            const sliders = ['height', 'minDepth', 'maxDepth', 'count', 'spacing', 'frequency', 'phase', 'waveType', 'controlPoints', 'displayResolution'];

            sliders.forEach(id => {
                const el = document.getElementById(id);
                el.addEventListener('input', () => {
                    updateValueDisplays();
                    updateCurveInfo();
                    generateRibs();
                });
            });

            document.getElementById('thickness').addEventListener('change', generateRibs);
            document.getElementById('color').addEventListener('input', generateRibs);

            document.getElementById('image-scale').addEventListener('input', (e) => {
                document.getElementById('image-scale-value').textContent = e.target.value;
                generateRibs();
            });
        }

        function setupImageUpload() {
            const dropZone = document.getElementById('image-drop-zone');
            const fileInput = document.getElementById('image-file-input');
            const clearBtn = document.getElementById('clear-image');

            dropZone.addEventListener('click', () => fileInput.click());

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) loadImage(e.target.files[0]);
            });

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                if (e.dataTransfer.files.length > 0) loadImage(e.dataTransfer.files[0]);
            });

            clearBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                clearImage();
            });
        }

        function loadImage(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    imageCanvas = document.createElement('canvas');
                    imageCanvas.width = img.width;
                    imageCanvas.height = img.height;
                    imageCtx = imageCanvas.getContext('2d');
                    imageCtx.drawImage(img, 0, 0);
                    imageData = imageCtx.getImageData(0, 0, img.width, img.height);

                    const preview = document.getElementById('image-preview');
                    preview.src = e.target.result;
                    preview.style.display = 'block';

                    document.getElementById('clear-image').style.display = 'block';
                    document.getElementById('image-scale-control').style.display = 'block';
                    document.getElementById('wave-controls').style.display = 'none';

                    const modeIndicator = document.getElementById('mode-indicator');
                    modeIndicator.textContent = 'Mode: Image Pattern';
                    modeIndicator.classList.remove('wave-mode');
                    modeIndicator.classList.add('image-mode');

                    generateRibs();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function clearImage() {
            imageData = null;
            imageCanvas = null;
            imageCtx = null;

            document.getElementById('image-preview').style.display = 'none';
            document.getElementById('clear-image').style.display = 'none';
            document.getElementById('image-scale-control').style.display = 'none';
            document.getElementById('wave-controls').style.display = 'block';
            document.getElementById('image-file-input').value = '';

            const modeIndicator = document.getElementById('mode-indicator');
            modeIndicator.textContent = 'Mode: Wave Pattern';
            modeIndicator.classList.remove('image-mode');
            modeIndicator.classList.add('wave-mode');

            generateRibs();
        }

        function sampleImageBrightness(u, v) {
            if (!imageData) return 0.5;

            const scale = parseFloat(document.getElementById('image-scale').value);

            let su = (u / scale) % 1;
            let sv = (v / scale) % 1;
            if (su < 0) su += 1;
            if (sv < 0) sv += 1;

            const px = Math.floor(su * (imageCanvas.width - 1));
            const py = Math.floor((1 - sv) * (imageCanvas.height - 1));

            const idx = (py * imageCanvas.width + px) * 4;
            const r = imageData.data[idx];
            const g = imageData.data[idx + 1];
            const b = imageData.data[idx + 2];

            return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        }

        function getParams() {
            return {
                height: parseFloat(document.getElementById('height').value),
                minDepth: parseFloat(document.getElementById('minDepth').value),
                maxDepth: parseFloat(document.getElementById('maxDepth').value),
                thickness: parseFloat(document.getElementById('thickness').value),
                count: parseInt(document.getElementById('count').value),
                spacing: parseFloat(document.getElementById('spacing').value),
                frequency: parseFloat(document.getElementById('frequency').value),
                phase: parseFloat(document.getElementById('phase').value),
                waveType: parseInt(document.getElementById('waveType').value),
                controlPoints: parseInt(document.getElementById('controlPoints').value),
                displayResolution: parseInt(document.getElementById('displayResolution').value),
                color: document.getElementById('color').value
            };
        }

        function waveFunction(t, frequency, waveType, phaseShift) {
            const angle = t * frequency * Math.PI * 2 + phaseShift;
            switch(waveType) {
                case 0: return Math.sin(angle);
                case 1: return Math.sin(angle) * Math.abs(Math.sin(angle));
                case 2: return Math.asin(Math.sin(angle)) / (Math.PI / 2);
                default: return Math.sin(angle);
            }
        }

        function generateControlPoints(params, ribIndex) {
            const { height, minDepth, maxDepth, frequency, phase, waveType, controlPoints, count } = params;
            const points = [];
            const depthRange = maxDepth - minDepth;
            const phaseShift = ribIndex * phase * Math.PI * 2;

            for (let i = 0; i < controlPoints; i++) {
                const t = i / (controlPoints - 1);
                const y = t * height;

                let depth;
                if (imageData) {
                    const u = count > 1 ? ribIndex / (count - 1) : 0.5;
                    const brightness = sampleImageBrightness(u, t);
                    depth = minDepth + brightness * depthRange;
                } else {
                    const wave = waveFunction(t, frequency, waveType, phaseShift);
                    depth = minDepth + (wave + 1) / 2 * depthRange;
                }

                points.push(new THREE.Vector2(depth, y));
            }

            return points;
        }

        function evaluateSplineCurve(controlPoints, resolution) {
            const curve = new THREE.SplineCurve(controlPoints);
            return curve.getPoints(resolution);
        }

        function createRibGeometry(profile, thickness, height) {
            const shape = new THREE.Shape();

            shape.moveTo(0, 0);

            profile.forEach((point) => {
                shape.lineTo(point.x * SCALE, point.y * SCALE);
            });

            shape.lineTo(0, height * SCALE);
            shape.lineTo(0, 0);

            const extrudeSettings = {
                depth: thickness * SCALE,
                bevelEnabled: false
            };

            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
        }

        function generateRibs() {
            // Clear existing
            ribMeshes.forEach(mesh => scene.remove(mesh));
            ribMeshes = [];
            ribProfiles = [];
            if (wallMesh) scene.remove(wallMesh);

            const params = getParams();
            const { height, thickness, count, spacing, displayResolution, color, maxDepth } = params;

            // Validate min/max
            const actualMinDepth = Math.min(params.minDepth, params.maxDepth);
            const actualMaxDepth = Math.max(params.minDepth, params.maxDepth);
            params.minDepth = actualMinDepth;
            params.maxDepth = actualMaxDepth;

            // Material
            const material = new THREE.MeshPhongMaterial({
                color: new THREE.Color(color),
                side: THREE.DoubleSide,
                shininess: 30
            });

            // Calculate positions
            const totalWidth = (count - 1) * spacing;
            const startZ = -(totalWidth * SCALE) / 2;

            // Generate each rib
            for (let i = 0; i < count; i++) {
                const controlPoints = generateControlPoints(params, i);
                const profile = evaluateSplineCurve(controlPoints, displayResolution);

                ribProfiles.push({
                    index: i,
                    profile: profile,
                    controlPoints: controlPoints,
                    height: height,
                    thickness: thickness
                });

                const geometry = createRibGeometry(profile, thickness, height);
                const mesh = new THREE.Mesh(geometry, material);

                mesh.position.z = startZ + i * spacing * SCALE - thickness * SCALE / 2;
                mesh.castShadow = true;
                mesh.receiveShadow = true;

                scene.add(mesh);
                ribMeshes.push(mesh);
            }

            // Wall backdrop
            const wallGeometry = new THREE.PlaneGeometry((totalWidth + 40) * SCALE, (height + 10) * SCALE);
            const wallMaterial = new THREE.MeshPhongMaterial({
                color: 0x3a3a40,
                side: THREE.DoubleSide
            });
            wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
            wallMesh.rotation.y = Math.PI / 2;
            wallMesh.position.set(-0.5 * SCALE, height * SCALE / 2, 0);
            wallMesh.receiveShadow = true;
            scene.add(wallMesh);

            // Update displays
            updateDimensionsDisplay(params, totalWidth);
        }

        function updateValueDisplays() {
            document.getElementById('heightVal').textContent = document.getElementById('height').value + '"';
            document.getElementById('minDepthVal').textContent = document.getElementById('minDepth').value + '"';
            document.getElementById('maxDepthVal').textContent = document.getElementById('maxDepth').value + '"';
            document.getElementById('countVal').textContent = document.getElementById('count').value;
            document.getElementById('spacingVal').textContent = document.getElementById('spacing').value + '"';
            document.getElementById('frequencyVal').textContent = document.getElementById('frequency').value;
            document.getElementById('phaseVal').textContent = document.getElementById('phase').value;
            document.getElementById('waveTypeVal').textContent = waveTypes[document.getElementById('waveType').value];
            document.getElementById('controlPointsVal').textContent = document.getElementById('controlPoints').value;
            document.getElementById('displayResolutionVal').textContent = document.getElementById('displayResolution').value;
        }

        function updateCurveInfo() {
            const height = parseFloat(document.getElementById('height').value);
            const controlPoints = parseInt(document.getElementById('controlPoints').value);
            const displayResolution = parseInt(document.getElementById('displayResolution').value);

            const controlSpacing = height / (controlPoints - 1);
            const segmentSize = height / displayResolution;

            document.getElementById('controlSpacing').textContent = controlSpacing.toFixed(2);
            document.getElementById('segmentSize').textContent = segmentSize.toFixed(3);
        }

        function updateDimensionsDisplay(params, totalWidth) {
            document.getElementById('ribCount').textContent = params.count;
            document.getElementById('totalWidth').textContent = totalWidth.toFixed(1) + '" (' + (totalWidth / 12).toFixed(1) + "')";
            document.getElementById('wallCoverage').textContent =
                (totalWidth / 12).toFixed(1) + "' wide x " + (params.height / 12).toFixed(1) + "' tall";

            const surfaceAreaPerRibSqIn = params.height * params.maxDepth;
            const surfaceAreaPerRibSqFt = surfaceAreaPerRibSqIn / 144;
            const totalSurfaceAreaSqFt = surfaceAreaPerRibSqFt * params.count;

            document.getElementById('surfaceArea').textContent = totalSurfaceAreaSqFt.toFixed(1) + ' sf';
            document.getElementById('surfaceAreaCalc').textContent = totalSurfaceAreaSqFt.toFixed(1) + ' sf';

            const totalPrice = totalSurfaceAreaSqFt * PRICE_PER_SF;
            document.getElementById('totalPrice').textContent = '$' + totalPrice.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
        }

        function setView(view) {
            const params = getParams();
            const totalWidth = (params.count - 1) * params.spacing * SCALE;
            const centerY = params.height * SCALE / 2;
            const maxD = params.maxDepth * SCALE;

            switch(view) {
                case 'front':
                    camera.position.set(maxD + 15, centerY, 0);
                    controls.target.set(0, centerY, 0);
                    break;
                case 'top':
                    camera.position.set(0, 20, 0);
                    controls.target.set(0, 0, 0);
                    break;
                case 'side':
                    camera.position.set(maxD / 2, centerY, totalWidth + 10);
                    controls.target.set(maxD / 2, centerY, 0);
                    break;
                case 'perspective':
                    camera.position.set(15, 10, 25);
                    controls.target.set(0, centerY, 0);
                    break;
            }
            controls.update();
        }

        function exportImage() {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = 'mr-walls-ribs.png';
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        }

        function exportDXF() {
            const params = getParams();
            const height = params.height;
            const maxDepth = params.maxDepth;
            const dxfSpacing = maxDepth * 1.2;

            let dxf = '';

            // DXF R12 format header
            dxf += '0\nSECTION\n2\nHEADER\n';
            dxf += '9\n$ACADVER\n1\nAC1009\n';
            dxf += '9\n$INSUNITS\n70\n1\n';
            dxf += '0\nENDSEC\n';

            // Tables section with layers
            dxf += '0\nSECTION\n2\nTABLES\n';
            dxf += '0\nTABLE\n2\nLAYER\n70\n2\n';
            dxf += '0\nLAYER\n2\nCURVES\n70\n0\n62\n5\n6\nCONTINUOUS\n';
            dxf += '0\nLAYER\n2\nLINES\n70\n0\n62\n7\n6\nCONTINUOUS\n';
            dxf += '0\nENDTAB\n';
            dxf += '0\nENDSEC\n';

            // Entities section
            dxf += '0\nSECTION\n2\nENTITIES\n';

            ribProfiles.forEach((rib, ribIndex) => {
                const offsetX = ribIndex * dxfSpacing;
                const profile = rib.profile;
                const firstPoint = profile[0];
                const lastPoint = profile[profile.length - 1];

                // Bottom edge line
                dxf += '0\nLINE\n8\nLINES\n';
                dxf += `10\n${offsetX.toFixed(6)}\n20\n0.0\n30\n0.0\n`;
                dxf += `11\n${(offsetX + firstPoint.x).toFixed(6)}\n21\n${firstPoint.y.toFixed(6)}\n31\n0.0\n`;

                // Curved edge as spline polyline
                dxf += '0\nPOLYLINE\n8\nCURVES\n66\n1\n70\n4\n';

                profile.forEach(point => {
                    dxf += '0\nVERTEX\n8\nCURVES\n';
                    dxf += `10\n${(offsetX + point.x).toFixed(6)}\n20\n${point.y.toFixed(6)}\n30\n0.0\n70\n8\n`;
                });

                dxf += '0\nSEQEND\n8\nCURVES\n';

                // Top edge line
                dxf += '0\nLINE\n8\nLINES\n';
                dxf += `10\n${(offsetX + lastPoint.x).toFixed(6)}\n20\n${lastPoint.y.toFixed(6)}\n30\n0.0\n`;
                dxf += `11\n${offsetX.toFixed(6)}\n21\n${height.toFixed(6)}\n31\n0.0\n`;

                // Left edge line (straight, at wall)
                dxf += '0\nLINE\n8\nLINES\n';
                dxf += `10\n${offsetX.toFixed(6)}\n20\n${height.toFixed(6)}\n30\n0.0\n`;
                dxf += `11\n${offsetX.toFixed(6)}\n21\n0.0\n31\n0.0\n`;
            });

            dxf += '0\nENDSEC\n0\nEOF\n';

            downloadFile(dxf, 'mr-walls-ribs.dxf', 'application/dxf');
        }

        function exportCSV() {
            const params = getParams();
            let csv = 'Rib Index,Height (in),Min Depth (in),Max Depth (in),Thickness (in),Phase Shift (rad)\n';

            for (let i = 0; i < params.count; i++) {
                const phaseShift = i * params.phase * Math.PI * 2;
                csv += `${i},${params.height},${params.minDepth},${params.maxDepth},${params.thickness},${phaseShift.toFixed(4)}\n`;
            }

            csv += `\nArray Settings\n`;
            csv += `Total Ribs,${params.count}\n`;
            csv += `Spacing,${params.spacing}"\n`;
            csv += `Total Width,${((params.count - 1) * params.spacing).toFixed(2)}"\n`;
            csv += `Wave Frequency,${params.frequency}\n`;
            csv += `Wave Type,${waveTypes[params.waveType]}\n`;
            csv += `Control Points,${params.controlPoints}\n`;
            csv += `Display Resolution,${params.displayResolution}\n`;

            const surfaceAreaPerRibSqFt = (params.height * params.maxDepth) / 144;
            const totalSurfaceAreaSqFt = surfaceAreaPerRibSqFt * params.count;
            csv += `\nPricing\n`;
            csv += `Surface Area per Rib,${surfaceAreaPerRibSqFt.toFixed(2)} sf\n`;
            csv += `Total Surface Area,${totalSurfaceAreaSqFt.toFixed(2)} sf\n`;
            csv += `Price per SF,$${PRICE_PER_SF}\n`;
            csv += `Total Price,$${(totalSurfaceAreaSqFt * PRICE_PER_SF).toFixed(2)}\n`;

            downloadFile(csv, 'mr-walls-ribs.csv', 'text/csv');
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize
        init();
        updateValueDisplays();
    </script>
</body>
</html>
